AWSTemplateFormatVersion: "2010-09-09"
Description: "Complete AgentCore deployment with VPC isolation and browser automation capabilities"

# This CloudFormation template deploys a complete Amazon Bedrock AgentCore
# environment with the following key features:
#
# 1. VPC ISOLATION: Secure private network with VPC endpoints for AWS services
# 2. BROWSER AUTOMATION: AgentCore browser tool for web interaction tasks
# 3. CONTAINER DEPLOYMENT: ECR repository with automated image building
# 4. SECURITY: IAM roles with least-privilege access patterns
# 5. MONITORING: CloudWatch integration for logging and observability
# 6. TESTING INFRASTRUCTURE: Development EC2 instance and sample web server
#
# Architecture Components:
# - Private VPC (10.1.0.0/16) with isolated subnets for AgentCore runtime
# - VPC endpoints for secure AWS service communication (no internet access)
# - ECR repository for container image storage with automated CodeBuild
# - AgentCore runtime with browser tool integration in private subnet
# - Development EC2 instance in public subnet for testing and validation
# - Sample web server for browser automation testing scenarios
# - S3 bucket for browser session recordings and audit trails
#
# Security Features:
# - Network isolation with security groups and NACLs
# - IAM roles with minimal required permissions
# - VPC endpoints prevent internet traffic for production workloads
# - Container image scanning and vulnerability assessment
#
# Deployment Time: ~15-20 minutes
# Supported Regions: us-east-1, us-west-2 (where AgentCore is available)

# PARAMETERS
Parameters:
  ImageTag:
    Type: String
    Default: "latest"
    Description: "Docker image tag for the AgentCore container - use 'latest' for development"
    AllowedPattern: "^[a-zA-Z0-9._-]+$"

  ECRRepositoryName:
    Type: String
    Default: "ecr"
    Description: "Name suffix for the ECR repository - will be prefixed with stack name"
    AllowedPattern: "^[a-z0-9-_]+$"
    ConstraintDescription: "Must be lowercase alphanumeric with hyphens and underscores only"

# RESOURCES

Resources:
  # ECR

  ECRRepository:
    Type: AWS::ECR::Repository
    DeletionPolicy: Delete
    UpdateReplacePolicy: Delete
    Properties:
      RepositoryName: !Sub "${AWS::StackName}-${ECRRepositoryName}"
      ImageTagMutability: IMMUTABLE
      EmptyOnDelete: true
      ImageScanningConfiguration:
        ScanOnPush: true
      RepositoryPolicyText:
        Version: "2012-10-17"
        Statement:
          - Sid: AllowPullFromAccount
            Effect: Allow
            Principal:
              AWS: !Sub "arn:aws:iam::${AWS::AccountId}:root"
            Action:
              - ecr:BatchGetImage
              - ecr:GetDownloadUrlForLayer
      Tags:
        - Key: StackName
          Value: !Ref AWS::StackName

  # IAM - Agent Execution Role
  AgentExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub "${AWS::StackName}-${AWS::Region}-agent-execution-role"
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Sid: AssumeRolePolicy
            Effect: Allow
            Principal:
              Service: bedrock-agentcore.amazonaws.com
            Action: sts:AssumeRole
            Condition:
              StringEquals:
                aws:SourceAccount: !Ref AWS::AccountId
              ArnLike:
                aws:SourceArn: !Sub "arn:aws:bedrock-agentcore:${AWS::Region}:${AWS::AccountId}:*"
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/BedrockAgentCoreFullAccess
      Policies:
        - PolicyName: AgentCoreExecutionPolicy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Sid: ECRImageAccess
                Effect: Allow
                Action:
                  - ecr:BatchGetImage
                  - ecr:GetDownloadUrlForLayer
                  - ecr:BatchCheckLayerAvailability
                Resource: !GetAtt ECRRepository.Arn
              - Sid: ECRTokenAccess
                Effect: Allow
                Action:
                  - ecr:GetAuthorizationToken
                Resource: "*"
              - Sid: CloudWatchLogs
                Effect: Allow
                Action:
                  - logs:DescribeLogStreams
                  - logs:CreateLogGroup
                  - logs:DescribeLogGroups
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: "*"
              - Sid: XRayTracing
                Effect: Allow
                Action:
                  - xray:PutTraceSegments
                  - xray:PutTelemetryRecords
                  - xray:GetSamplingRules
                  - xray:GetSamplingTargets
                Resource: "*"
              - Sid: CloudWatchMetrics
                Effect: Allow
                Resource: "*"
                Action: cloudwatch:PutMetricData
                Condition:
                  StringEquals:
                    cloudwatch:namespace: bedrock-agentcore
              - Sid: GetAgentAccessToken
                Effect: Allow
                Action:
                  - bedrock-agentcore:GetWorkloadAccessToken
                  - bedrock-agentcore:GetWorkloadAccessTokenForJWT
                  - bedrock-agentcore:GetWorkloadAccessTokenForUserId
                Resource:
                  - !Sub "arn:aws:bedrock-agentcore:${AWS::Region}:${AWS::AccountId}:workload-identity-directory/default"
                  - !Sub "arn:aws:bedrock-agentcore:${AWS::Region}:${AWS::AccountId}:workload-identity-directory/default/workload-identity/*"
              - Sid: BedrockModelInvocation
                Effect: Allow
                Action:
                  - bedrock:InvokeModel
                  - bedrock:InvokeModelWithResponseStream
                Resource: "*"
              - Sid: S3BucketAccess
                Effect: Allow
                Action:
                  - s3:GetObject
                  - s3:PutObject
                  - s3:DeleteObject
                  - s3:GetObjectVersion
                  - s3:PutObjectAcl
                Resource:
                  - !Sub "${RecordingBucket.Arn}/*"
              - Sid: S3BucketListAccess
                Effect: Allow
                Action:
                  - s3:ListBucket
                  - s3:GetBucketLocation
                Resource:
                  - !GetAtt RecordingBucket.Arn

      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-agent-execution-role"
        - Key: StackName
          Value: !Ref AWS::StackName
        - Key: Module
          Value: IAM

  # CodeBuild Role
  CodeBuildRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub "${AWS::StackName}-${AWS::Region}-codebuild-role"
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: codebuild.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: CodeBuildPolicy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Sid: CloudWatchLogs
                Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/codebuild/*"
              - Sid: ECRAccess
                Effect: Allow
                Action:
                  - ecr:BatchCheckLayerAvailability
                  - ecr:GetDownloadUrlForLayer
                  - ecr:BatchGetImage
                  - ecr:GetAuthorizationToken
                  - ecr:PutImage
                  - ecr:InitiateLayerUpload
                  - ecr:UploadLayerPart
                  - ecr:CompleteLayerUpload
                Resource:
                  - !GetAtt ECRRepository.Arn
                  - "*"
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-codebuild-role"
        - Key: StackName
          Value: !Ref AWS::StackName
        - Key: Module
          Value: IAM

  # Lambda Custom Resource Role
  CustomResourceRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub "${AWS::StackName}-${AWS::Region}-custom-resource-role"
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: CustomResourcePolicy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Sid: ECRAccess
                Effect: Allow
                Action:
                  - ecr:ListImages
                  - ecr:BatchDeleteImage
                  - ecr:GetAuthorizationToken
                  - ecr:BatchGetImage
                  - ecr:GetDownloadUrlForLayer
                  - ecr:PutImage
                  - ecr:InitiateLayerUpload
                  - ecr:UploadLayerPart
                  - ecr:CompleteLayerUpload
                Resource: !GetAtt ECRRepository.Arn
              - Sid: CodeBuildAccess
                Effect: Allow
                Action:
                  - codebuild:StartBuild
                  - codebuild:BatchGetBuilds
                  - codebuild:BatchGetProjects
                Resource: !GetAtt AgentImageBuildProject.Arn
              - Sid: BedrockAgentCoreMemoryAccess
                Effect: Allow
                Action:
                  - bedrock-agentcore:CreateEvent
                  - bedrock-agentcore:ListEvents
                  - bedrock-agentcore:GetMemory
                Resource: "*"
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-custom-resource-role"
        - Key: StackName
          Value: !Ref AWS::StackName
        - Key: Module
          Value: IAM

  # LAMBDA - CodeBuild Trigger Function
  CodeBuildTriggerFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub "${AWS::StackName}-codebuild-trigger"
      Description: "Triggers CodeBuild projects as CloudFormation custom resource"
      Handler: index.handler
      Role: !GetAtt CustomResourceRole.Arn
      Runtime: python3.13
      Timeout: 900
      Code:
        ZipFile: |
          import boto3
          import cfnresponse
          import json
          import logging
          import time

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          def handler(event, context):
              logger.info('Received event: %s', json.dumps(event))
              
              try:
                  if event['RequestType'] == 'Delete':
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
                      return
                  
                  project_name = event['ResourceProperties']['ProjectName']
                  wait_for_completion = event['ResourceProperties'].get('WaitForCompletion', 'true').lower() == 'true'
                  
                  logger.info(f"Attempting to start CodeBuild project: {project_name}")
                  logger.info(f"Wait for completion: {wait_for_completion}")
                  
                  # Start the CodeBuild project
                  codebuild = boto3.client('codebuild')
                  
                  # First, verify the project exists
                  try:
                      project_info = codebuild.batch_get_projects(names=[project_name])
                      if not project_info['projects']:
                          raise Exception(f"CodeBuild project '{project_name}' not found")
                      logger.info(f"CodeBuild project '{project_name}' found")
                  except Exception as e:
                      logger.error(f"Error checking project existence: {str(e)}")
                      raise
                  
                  response = codebuild.start_build(projectName=project_name)
                  build_id = response['build']['id']
                  
                  logger.info(f"Successfully started build: {build_id}")
                  
                  if not wait_for_completion:
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, {
                          'BuildId': build_id,
                          'Status': 'STARTED'
                      })
                      return
                  
                  # Wait for the build to complete
                  max_wait_time = context.get_remaining_time_in_millis() / 1000 - 30  # Leave 30s buffer
                  start_time = time.time()
                  
                  while True:
                      if time.time() - start_time > max_wait_time:
                          error_message = f"Build {build_id} timed out"
                          logger.error(error_message)
                          cfnresponse.send(event, context, cfnresponse.FAILED, {'Error': error_message})
                          return
                      
                      build_response = codebuild.batch_get_builds(ids=[build_id])
                      build_status = build_response['builds'][0]['buildStatus']
                      
                      if build_status == 'SUCCEEDED':
                          logger.info(f"Build {build_id} succeeded")
                          cfnresponse.send(event, context, cfnresponse.SUCCESS, {
                              'BuildId': build_id,
                              'Status': build_status
                          })
                          return
                      elif build_status in ['FAILED', 'FAULT', 'STOPPED', 'TIMED_OUT']:
                          error_message = f"Build {build_id} failed with status: {build_status}"
                          logger.error(error_message)
                          
                          # Get build logs for debugging
                          try:
                              logs_info = build_response['builds'][0].get('logs', {})
                              if logs_info.get('groupName') and logs_info.get('streamName'):
                                  logger.info(f"Build logs available in CloudWatch")
                          except Exception as log_error:
                              logger.warning(f"Could not get log information: {log_error}")
                          
                          cfnresponse.send(event, context, cfnresponse.FAILED, {
                              'Error': error_message,
                              'BuildId': build_id
                          })
                          return
                      
                      logger.info(f"Build {build_id} status: {build_status}")
                      time.sleep(30)  # Check every 30 seconds
                  
              except Exception as e:
                  logger.error('Error: %s', str(e))
                  cfnresponse.send(event, context, cfnresponse.FAILED, {
                      'Error': str(e)
                  })
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-codebuild-trigger"
        - Key: StackName
          Value: !Ref AWS::StackName
        - Key: Module
          Value: Lambda

  # CODEBUILD
  AgentImageBuildProject:
    Type: AWS::CodeBuild::Project
    Properties:
      Name: !Sub "${AWS::StackName}-agent-build"
      Description: !Sub "Build AgentCore container with browser automation for ${AWS::StackName}"
      ServiceRole: !GetAtt CodeBuildRole.Arn
      Artifacts:
        Type: NO_ARTIFACTS
      Environment:
        Type: ARM_CONTAINER
        ComputeType: BUILD_GENERAL1_LARGE
        Image: aws/codebuild/amazonlinux2-aarch64-standard:3.0
        PrivilegedMode: true
        EnvironmentVariables:
          - Name: AWS_DEFAULT_REGION
            Value: !Ref AWS::Region
          - Name: AWS_ACCOUNT_ID
            Value: !Ref AWS::AccountId
          - Name: IMAGE_REPO_NAME
            Value: !Ref ECRRepository
          - Name: IMAGE_TAG
            Value: !Ref ImageTag
          - Name: STACK_NAME
            Value: !Ref AWS::StackName
      Source:
        Type: NO_SOURCE
        BuildSpec: |
          version: 0.2
          phases:
            pre_build:
              commands:
                - echo Logging in to Amazon ECR...
                - aws ecr get-login-password --region $AWS_DEFAULT_REGION | docker login --username AWS --password-stdin $AWS_ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com
            build:
              commands:
                - echo Build started on `date`
                - echo Building the Docker image for default agent ARM64...

                # Create requirements.txt
                - |
                  cat > requirements.txt << 'EOF'
                  # strands-agents
                  # strands-agents-tools
                  # uv
                  boto3
                  bedrock-agentcore
                  # bedrock-agentcore-starter-toolkit
                  browser-use
                  # langchain-aws>=0.1.0
                  # rich
                  EOF

                # Create my_agent.py
                - |
                  cat > my_agent.py << 'EOF'


                  import shutil
                  import sys
                  from pathlib import Path
                  from bedrock_agentcore.runtime import BedrockAgentCoreApp
                  from bedrock_agentcore.tools.browser_client import BrowserClient
                  import asyncio, os
                  from boto3.session import Session


                  def find_browser_use_path():
                      """Automatically find the browser_use installation path"""
                      try:
                          import browser_use
                          browser_use_path = Path(browser_use.__file__).parent
                          session_file = browser_use_path / "browser" / "session.py"
                          return str(session_file)
                      except ImportError:
                          print("âŒ browser_use not installed. Install with: pip install browser-use")
                          return None

                  def patch_browser_use():

                      # Auto-detect file path
                      file_path = find_browser_use_path()
                      if not file_path:
                          return False
                      
                      if not os.path.exists(file_path):
                          print(f"âŒ File not found: {file_path}")
                          return False
                      
                      print(f"ðŸ“ Found browser_use at: {file_path}")
                      
                      # Create backup
                      backup_path = file_path + ".backup"
                      if not os.path.exists(backup_path):
                          shutil.copy2(file_path, backup_path)
                          print(f"ðŸ’¾ Created backup: {backup_path}")
                      else:
                          print(f"ðŸ“‹ Backup already exists: {backup_path}")
                      
                      # Read file
                      with open(file_path, 'r') as f:
                          content = f.read()
                      
                      # Replacement 1: Add headers check after cdp_url check
                      old1 = "if not cdp_url:\n\t\t\tprofile_kwargs['is_local'] = True"
                      new1 = "if not cdp_url:\n\t\t\tprofile_kwargs['is_local'] = True\n\n\t\tif headers:\n\t\t\tprofile_kwargs['headers'] = headers"
                      
                      if old1 in content and "if headers:\n\t\t\tprofile_kwargs['headers'] = headers" not in content:
                          content = content.replace(old1, new1)
                          print("âœ… Added headers check")
                      elif "if headers:\n\t\t\tprofile_kwargs['headers'] = headers" in content:
                          print("âœ… Headers check already exists")
                      else:
                          print("âš ï¸ Headers check pattern not found")
                      
                      # Replacement 2: Add headers to CDPClient
                      old2 = "self._cdp_client_root = CDPClient(self.cdp_url)"
                      new2 = "self._cdp_client_root = CDPClient(self.cdp_url,  additional_headers=self.browser_profile.headers)"
                      
                      if old2 in content:
                          content = content.replace(old2, new2)
                          print("âœ… Added headers to CDPClient")
                      elif "additional_headers=self.browser_profile.headers" in content:
                          print("âœ… CDPClient headers already exists")
                      else:
                          print("âš ï¸ CDPClient pattern not found")
                      
                      # Write back
                      with open(file_path, 'w') as f:
                          f.write(content)
                      
                      print("ðŸŽ‰ Patching complete!")
                      return True

                  patch_browser_use()

                  # Load the updated libraries 
                  from browser_use.llm import ChatAnthropicBedrock, ChatAWSBedrock
                  from browser_use import Agent
                  from browser_use import Browser, BrowserProfile



                  BROWSER_ID = os.getenv('BROWSER_ID', None)
                  AWS_REGION = os.getenv('AWS_REGION','us-west-2')
                  WEB_SERVER = os.getenv('WEB_SERVER','')
                  boto_session = Session(region_name=AWS_REGION)
                  region = boto_session.region_name
                  app = BedrockAgentCoreApp()

                  async def run_browser_task(browser_session: Browser, bedrock_chat: ChatAnthropicBedrock, task: str) -> None:
                      try:
                          # Create and run the agent
                          agent = Agent(
                              task=task,
                              llm=bedrock_chat,
                              browser_session=browser_session
                          )   
                          await agent.run()

                      except Exception as e:
                          raise

                  @app.async_task
                  async def async_main(query): 

                      # Create persistent browser session and model
                      browser_session = None
                      bedrock_chat = None
                      client = BrowserClient(region)

                      try:
                          if BROWSER_ID:
                              client.start(identifier=BROWSER_ID)
                          else:
                              client.start()
                          print("Browser session started successfully!")

                          # Extract ws_url and headers
                          ws_url, headers = client.generate_ws_headers()
                          print(ws_url)
                          # print(headers)

                          # Create browser profile with headers and timeout 
                          browser_profile = BrowserProfile(
                              headers=headers,
                              timeout=1500000,  # 150 seconds timeout
                          )

                          # Create a browser session with CDP URL and keep_alive=True for persistence
                          browser_session = Browser(
                              cdp_url=ws_url,
                              browser_profile=browser_profile,
                              keep_alive=True
                          )

                          # Initialize the browser session
                          await browser_session.start()

                          # Create ChatBedrockConverse once
                          bedrock_chat = ChatAnthropicBedrock(
                              model='global.anthropic.claude-haiku-4-5-20251001-v1:0',
                              aws_region=AWS_REGION
                          )

                          task = f"Access {WEB_SERVER} over http at port 8080 to check what are holidays in November " ## Modify the task to run other tasks

                          if query:
                              task = query

                          await run_browser_task(browser_session, bedrock_chat, task)

                      finally:
                          # Close the browser session
                          client.stop()
                          print("âœ… Browser session closed")


                  @app.entrypoint
                  async def invoke(payload=None):
                      try:
                          # change
                          query = payload.get("prompt")

                          asyncio.create_task(async_main(query))
                          
                          msg = (
                              "Processing started ... "
                              f"You can monitor status in CloudWatch logs at /aws/bedrock-agentcore/runtimes/<agent-runtime-id> ....."
                          )

                          return {
                              "status": "Started",
                              "message": msg
                          }
                          
                      except Exception as e:
                          return {"error": str(e)}


                  if __name__ == "__main__":
                      app.run()
                  EOF


                # Step 1.3: Create Dockerfile
                - |
                  cat > Dockerfile << 'EOF'
                  FROM public.ecr.aws/docker/library/python:3.13-slim
                  WORKDIR /app

                  COPY requirements.txt requirements.txt
                  RUN pip install -r requirements.txt

                  # Create non-root user
                  # RUN useradd -m -u 1000 bedrock_agentcore
                  # USER bedrock_agentcore
                  USER root

                  EXPOSE 8080
                  EXPOSE 8000

                  COPY . . 

                  CMD ["python", "-m", "my_agent"]

                  EOF

                # Step 1.5: Build the image
                - echo Building ARM64 image...
                - docker build -t $IMAGE_REPO_NAME:$IMAGE_TAG .
                - docker tag $IMAGE_REPO_NAME:$IMAGE_TAG $AWS_ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com/$IMAGE_REPO_NAME:$IMAGE_TAG
            
            post_build:
              commands:
                - echo Build completed on `date`
                - echo Pushing the Docker image...
                - docker push $AWS_ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com/$IMAGE_REPO_NAME:$IMAGE_TAG
                - echo ARM64 Docker image pushed successfully
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-build"
        - Key: StackName
          Value: !Ref AWS::StackName

  # CUSTOM RESOURCE - Trigger Container Image Build
  TriggerImageBuild:
    Type: Custom::CodeBuildTrigger
    DependsOn:
      - ECRRepository # Ensure ECR repository exists first
      - AgentImageBuildProject # Ensure CodeBuild project is ready
      - CodeBuildTriggerFunction # Ensure Lambda function is deployed
    Properties:
      ServiceToken: !GetAtt CodeBuildTriggerFunction.Arn
      ProjectName: !Ref AgentImageBuildProject
      WaitForCompletion: "true" # Wait for build to complete before proceeding

  # VPC

  ClientVPC:
    Type: AWS::EC2::VPC
    Properties:
      CidrBlock: "10.1.0.0/16"
      EnableDnsHostnames: true
      EnableDnsSupport: true
      Tags:
        - Key: Name
          Value: vpc-client

  # Private subnet to host the AgentCore Application
  ClientPrivateSubnet1:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref ClientVPC
      CidrBlock: "10.1.1.0/24"
      AvailabilityZone: !Select [1, !GetAZs ""]
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-private-subnet-1"
        - Key: Type
          Value: Private

  # Security Group for AgentCore Runtime - Controls network access for agent instances
  AgentCoreRuntimeSG:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: "Security group for AgentCore Runtime - allows outbound HTTPS to VPC endpoints only"
      VpcId: !Ref ClientVPC
      # No egress rules initially
      Tags:
        - Key: Name
          Value: agentcore-runtime-sg

  # Security Group for VPC Endpoints - Controls access to AWS services via VPC endpoints
  VPCEndpointSG:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: "Security group for VPC endpoints - allows HTTPS from AgentCore runtime"
      VpcId: !Ref ClientVPC
      SecurityGroupEgress:
      - IpProtocol: "-1"
        CidrIp: "127.0.0.1/32"
        Description: "Explicit deny-all egress rule for VPC endpoints (no outbound needed)"
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-vpc-endpoint-sg"

  # Security Group for Browser tool
  BrowserToolSG:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: "Security group for Browser Tool - allows HTTPS from AgentCore runtime"
      VpcId: !Ref ClientVPC
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-browser-tool-sg"

  # VPC ENDPOINTS

  # AgentCore VPC Endpoint
  AgentCoreVPCEndpoint:
    Type: AWS::EC2::VPCEndpoint
    Properties:
      VpcId: !Ref ClientVPC
      ServiceName: !Sub "com.amazonaws.${AWS::Region}.bedrock-agentcore"
      VpcEndpointType: Interface
      SubnetIds:
        - !Ref ClientPrivateSubnet1
      SecurityGroupIds:
        - !Ref VPCEndpointSG
      PrivateDnsEnabled: true
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal: "*"
            Action: "*"
            Resource: "*"
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-agentcore-endpoint"

  # VPC Endpoint for ECR API - Enables container registry API access
  ECRAPIVPCEndpoint:
    Type: AWS::EC2::VPCEndpoint
    Properties:
      VpcId: !Ref ClientVPC
      ServiceName: !Sub "com.amazonaws.${AWS::Region}.ecr.api"
      VpcEndpointType: Interface
      SubnetIds:
        - !Ref ClientPrivateSubnet1
      SecurityGroupIds:
        - !Ref VPCEndpointSG
      PrivateDnsEnabled: true
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal: "*"
            Action: "*"
            Resource: "*"
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-ecr-api-endpoint"

  # VPC Endpoint for ECR Docker Registry - Enables container image downloads
  ECRDKRVPCEndpoint:
    Type: AWS::EC2::VPCEndpoint
    Properties:
      VpcId: !Ref ClientVPC
      ServiceName: !Sub "com.amazonaws.${AWS::Region}.ecr.dkr"
      VpcEndpointType: Interface
      SubnetIds:
        - !Ref ClientPrivateSubnet1
      SecurityGroupIds:
        - !Ref VPCEndpointSG
      PrivateDnsEnabled: true
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal: "*"
            Action: "*"
            Resource: "*"
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-ecr-dkr-endpoint"

  # VPC Endpoint for CloudWatch Logs - Enables logging from AgentCore runtime
  CloudLogVPCEndpoint:
    Type: AWS::EC2::VPCEndpoint
    Properties:
      VpcId: !Ref ClientVPC
      ServiceName: !Sub "com.amazonaws.${AWS::Region}.logs"
      VpcEndpointType: Interface
      SubnetIds:
        - !Ref ClientPrivateSubnet1
      SecurityGroupIds:
        - !Ref VPCEndpointSG
      PrivateDnsEnabled: true
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal: "*"
            Action: "*"
            Resource: "*"
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-cloudwatch-logs-endpoint"

  # VPC Endpoint for Bedrock Runtime - Enables LLM model inference
  BedrockRuntimeVPCEndpoint:
    Type: AWS::EC2::VPCEndpoint
    Properties:
      VpcId: !Ref ClientVPC
      ServiceName: !Sub "com.amazonaws.${AWS::Region}.bedrock-runtime"
      VpcEndpointType: Interface
      SubnetIds:
        - !Ref ClientPrivateSubnet1
      SecurityGroupIds:
        - !Ref VPCEndpointSG
      PrivateDnsEnabled: true
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal: "*"
            Action: "*"
            Resource: "*"
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-bedrock-runtime-endpoint"

  # SECURITY GROUP RULES

  # AgentCore to VPC endpoints HTTPS
  AgentCoreRuntimeEgressRule:
    Type: AWS::EC2::SecurityGroupEgress
    Properties:
      GroupId: !Ref AgentCoreRuntimeSG
      IpProtocol: tcp
      FromPort: 443
      ToPort: 443
      DestinationSecurityGroupId: !Ref VPCEndpointSG
      Description: "Allow outbound HTTPS from AgentCore Runtime to VPC endpoints"

  # Allow HTTPS Traffic from AgentCore Runtime to Browser
  AgentCoreRuntimeEgressRule1:
    Type: AWS::EC2::SecurityGroupEgress
    Properties:
      GroupId: !Ref AgentCoreRuntimeSG
      IpProtocol: tcp
      FromPort: 443
      ToPort: 443
      DestinationSecurityGroupId: !Ref BrowserToolSG
      Description: "Allow outbound HTTPS from AgentCore Runtime to Browser Tool"

  # Allow VPC endpoints to receive HTTPS traffic from AgentCore Runtime
  VPCEndpointIngressRule:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      GroupId: !Ref VPCEndpointSG
      IpProtocol: tcp
      FromPort: 443
      ToPort: 443
      SourceSecurityGroupId: !Ref AgentCoreRuntimeSG
      Description: "Allow inbound HTTPS from AgentCore runtime to VPC endpoints"

    # Allow Browser Tool to receive HTTPS traffic from AgentCore Runtime
  BrowserToolIngressRule:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      GroupId: !Ref BrowserToolSG
      IpProtocol: tcp
      FromPort: 443
      ToPort: 443
      SourceSecurityGroupId: !Ref AgentCoreRuntimeSG
      Description: "Allow inbound HTTPS from AgentCore runtime to VPC endpoints"

  # Allow Browser Tool to reach webserver
  BrowserToolEgressRule:
    Type: AWS::EC2::SecurityGroupEgress
    Properties:
      GroupId: !Ref BrowserToolSG
      IpProtocol: tcp
      FromPort: 0
      ToPort: 65535
      DestinationSecurityGroupId: !Ref WebServerSecurityGroup
      Description: "Allow inbound HTTPS from AgentCore runtime to VPC endpoints"

  # WEB APPLICATION

  # Web Server Security Group
  WebServerSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Security group for web server in private subnet
      VpcId: !Ref ClientVPC
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 0
          ToPort: 65535
          CidrIp: 10.1.0.0/16
      SecurityGroupEgress:
        - IpProtocol: -1
          CidrIp: 0.0.0.0/0
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-webserver-sg"

  # Web Server EC2 Instance in Private Subnet
  WebServerInstance:
    Type: AWS::EC2::Instance
    Properties:
      ImageId: !Sub "{{resolve:ssm:/aws/service/ami-amazon-linux-latest/al2023-ami-kernel-6.1-x86_64}}"
      InstanceType: t3.micro
      SubnetId: !Ref ClientPrivateSubnet1
      SecurityGroupIds:
        - !Ref WebServerSecurityGroup
      UserData:
        Fn::Base64: !Sub |
          #!/bin/bash
          # Use Python's built-in web server (no installation needed)
          mkdir -p /var/www/html
          cd /var/www/html
          cat > index.html << 'EOF'
          <!DOCTYPE html>
          <html>
              <head>
                  <title>US Holidays</title>
                  <style>
                      body{font-family:Arial,sans-serif;margin:40px;background:#f5f5f5}
                      .container{max-width:800px;margin:0 auto;background:#fff;padding:20px;border-radius:10px;box-shadow:0 2px 10px rgba(0,0,0,.1)}
                      .header{background:#232f3e;color:#fff;padding:20px;margin-bottom:10px;text-align:center}
                      table{width:100%;border-collapse:collapse}
                      th,td{padding:8px;border:1px solid #ddd}
                      th{background:#232f3e;color:#fff}
                  </style>
              </head>
              <body>
                  <div class="container">
                      <div class="header"><h1>US Holiday List</h1></div>
                      <table>
                          <tr><th>Holiday</th><th>Date</th><th>Day</th></tr>
                          <tr><td>New Year's Day</td><td>Jan 1</td><td>Wed</td></tr>
                          <tr><td>MLK Jr. Day</td><td>Jan 20</td><td>Mon</td></tr>
                          <tr><td>Presidents' Day</td><td>Feb 17</td><td>Mon</td></tr>
                          <tr><td>Memorial Day</td><td>May 26</td><td>Mon</td></tr>
                          <tr><td>Juneteenth</td><td>Jun 19</td><td>Thu</td></tr>
                          <tr><td>Independence Day</td><td>Jul 4</td><td>Fri</td></tr>
                          <tr><td>Labor Day</td><td>Sep 1</td><td>Mon</td></tr>
                          <tr><td>Columbus Day</td><td>Oct 13</td><td>Mon</td></tr>
                          <tr><td>Veterans Day</td><td>Nov 11</td><td>Tue</td></tr>
                          <tr><td>Thanksgiving</td><td>Nov 27</td><td>Thu</td></tr>
                          <tr><td>Christmas Day</td><td>Dec 25</td><td>Thu</td></tr>
                      </table>
                  </div>
              </body>
          </html>

          EOF

          chmod -R 755 /var/www/html

          # Set proper ownership and permissions
          chown -R ec2-user:ec2-user /var/www/html

          # Start Python web server on port 8080 as ec2-user (no root required)
          cd /var/www/html
          su - ec2-user -c "cd /var/www/html && nohup python3 -m http.server 8080 > /home/ec2-user/webserver.log 2>&1 &"
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-webserver"

  # EC2 TESTING

  # Public Subnet for EC2
  ClientPublicSubnet1:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref ClientVPC
      CidrBlock: "10.1.100.0/28" # Small subnet (16 IPs) for testing instances
      AvailabilityZone: !Select [0, !GetAZs ""] # Use first AZ
      MapPublicIpOnLaunch: true # Auto-assign public IPs for internet access
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-public-subnet-1"
        - Key: Type
          Value: Public

  # Internet Gateway - Provides internet access for public subnet
  ClientInternetGateway:
    Type: AWS::EC2::InternetGateway
    Properties:
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-igw"

  # Attach Internet Gateway to VPC
  ClientInternetGatewayAttachment:
    Type: AWS::EC2::VPCGatewayAttachment
    Properties:
      VpcId: !Ref ClientVPC
      InternetGatewayId: !Ref ClientInternetGateway

  # Route Table for Public Subnet - Defines routing rules for public traffic
  ClientPublicRouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref ClientVPC
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-public-rt"

  # Default Route - Directs all internet traffic through Internet Gateway
  ClientPublicRoute:
    Type: AWS::EC2::Route
    DependsOn: ClientInternetGatewayAttachment
    Properties:
      RouteTableId: !Ref ClientPublicRouteTable
      DestinationCidrBlock: 0.0.0.0/0
      GatewayId: !Ref ClientInternetGateway

  # Associate Public Subnet with Route Table
  ClientPublicSubnetRouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref ClientPublicSubnet1
      RouteTableId: !Ref ClientPublicRouteTable

  # IAM Role for EC2 Development Instance
  EC2InstanceRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub "${AWS::StackName}-${AWS::Region}-ec2-instance-role"
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: ec2.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore
      Policies:
        - PolicyName: EC2InstancePolicy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Sid: CloudWatchLogs
                Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                  - logs:DescribeLogStreams
                  - logs:DescribeLogGroups
                Resource: "*"
              - Sid: BedrockAccess
                Effect: Allow
                Action:
                  - bedrock:InvokeModel
                  - bedrock:InvokeModelWithResponseStream
                  - bedrock-agentcore:InvokeAgentRuntime
                Resource: "*"
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-${AWS::Region}-ec2-instance-role"
        - Key: StackName
          Value: !Ref AWS::StackName

  # Instance Profile - Attaches IAM role to EC2 instance
  EC2InstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      InstanceProfileName: !Sub "${AWS::StackName}-${AWS::Region}-ec2-instance-profile"
      Roles:
        - !Ref EC2InstanceRole

  # Security Group for Development EC2 Instance
  EC2InstanceSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: "Security group for development EC2 instance - allows SSH and outbound HTTPS"
      VpcId: !Ref ClientVPC
      SecurityGroupIngress:
        # SSH Access - For development and troubleshooting
        - IpProtocol: tcp
          FromPort: 22
          ToPort: 22
          CidrIp: 0.0.0.0/0 # Note: In production, restrict to specific IP ranges
          Description: "Allow SSH access for development and troubleshooting"
      SecurityGroupEgress:
        # VPC Endpoint Access - For AWS service communication
        - IpProtocol: tcp
          FromPort: 443
          ToPort: 443
          DestinationSecurityGroupId: !Ref VPCEndpointSG
          Description: "Allow outbound HTTPS to VPC endpoints from EC2 Instance"
        # AgentCore Runtime Access - For testing agent invocation
        - IpProtocol: tcp
          FromPort: 443
          ToPort: 443
          DestinationSecurityGroupId: !Ref AgentCoreRuntimeSG
          Description: "Allow outbound HTTPS to AgentCore Runtime from EC2 Instance"
        # Internet Access - For package downloads and updates
        - IpProtocol: tcp
          FromPort: 443
          ToPort: 443
          CidrIp: 0.0.0.0/0
          Description: "Allow HTTPS outbound to internet"
        - IpProtocol: tcp
          FromPort: 80
          ToPort: 80
          CidrIp: 0.0.0.0/0
          Description: "Allow HTTP outbound to internet"
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-ec2-instance-sg"
        - Key: Purpose
          Value: "Development Instance Security"

  # Additional Security Group Rule - Allow EC2 to access VPC endpoints
  VPCEndpointIngressFromEC2Rule:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      GroupId: !Ref VPCEndpointSG
      IpProtocol: tcp
      FromPort: 443
      ToPort: 443
      SourceSecurityGroupId: !Ref EC2InstanceSecurityGroup
      Description: "Allow inbound HTTPS from EC2 Instance to VPC endpoints"

  # Development EC2 Instance - For testing AgentCore integration
  DevelopmentInstance:
    Type: AWS::EC2::Instance
    Properties:
      ImageId: !Sub "{{resolve:ssm:/aws/service/ami-amazon-linux-latest/al2023-ami-kernel-6.1-arm64}}" # Latest Amazon Linux 2023 ARM64
      InstanceType: "t4g.small" # ARM64 instance type for cost efficiency
      IamInstanceProfile: !Ref EC2InstanceProfile
      SecurityGroupIds:
        - !Ref EC2InstanceSecurityGroup
      SubnetId: !Ref ClientPublicSubnet1
      KeyName: !Ref "AWS::NoValue" # No SSH key - use SSM Session Manager instead

      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-dev-instance"

  # AGENTCORE

  # AgentCore Runtime
  AgentRuntime:
    Type: AWS::BedrockAgentCore::Runtime
    DependsOn:
      - TriggerImageBuild # Ensure container image is built first
      - BrowserTool # Ensure browser tool is available
      - WebServerInstance
    Properties:
      AgentRuntimeName: !Sub
        - "${StackNameUnderscore}_runtime"
        - StackNameUnderscore: !Join ["_", !Split ["-", !Ref "AWS::StackName"]]
      AgentRuntimeArtifact:
        ContainerConfiguration:
          ContainerUri: !Sub "${ECRRepository.RepositoryUri}:${ImageTag}" # Use built container image
      RoleArn: !GetAtt AgentExecutionRole.Arn
      NetworkConfiguration:
        NetworkMode: "VPC" # Deploy in VPC for security isolation
        NetworkModeConfig:
          Subnets:
            - !Ref ClientPrivateSubnet1 # Private subnet with no internet access
          SecurityGroups:
            - !Ref AgentCoreRuntimeSG # Restricted security group
      Description: !Sub "AgentCore runtime with browser automation for ${AWS::StackName}"
      EnvironmentVariables:
        BROWSER_ID: !GetAtt BrowserTool.BrowserId # Connect to browser tool
        AWS_REGION: !Sub "${AWS::Region}" # AWS region for service calls
        WEB_SERVER: !GetAtt WebServerInstance.PrivateIp

  RecordingBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub "${AWS::StackName}-browser-recording"
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      VersioningConfiguration:
        Status: Enabled
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256
            BucketKeyEnabled: true
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-browser-recording"
        - Key: StackName
          Value: !Ref AWS::StackName

  # Browser Tool - Provides web automation capabilities
  BrowserTool:
    Type: AWS::BedrockAgentCore::BrowserCustom
    Properties:
      Name: !Sub
        - "${StackNameUnderscore}_browser"
        - StackNameUnderscore: !Join ["_", !Split ["-", !Ref "AWS::StackName"]]
      Description: !Sub "Browser tool for ${AWS::StackName} - enables web automation and scraping"
      ExecutionRoleArn: !GetAtt AgentExecutionRole.Arn
      NetworkConfiguration:
        NetworkMode: "VPC" # Deploy in VPC for security isolation
        VpcConfig:
          Subnets:
            - !Ref ClientPrivateSubnet1
          SecurityGroups:
            - !Ref BrowserToolSG
      RecordingConfig:
        Enabled: true
        S3Location:
          "Bucket": !Ref RecordingBucket
          "Prefix": recordings

# OUTPUTS
Outputs:

  AgentRuntimeArn:
    Description: "Unique identifier of the created AgentCore runtime"
    Value: !GetAtt AgentRuntime.AgentRuntimeArn
    Export:
      Name: !Sub "${AWS::StackName}-AgentRuntimeArn"

  # DEVELOPMENT MODULE OUTPUTS
  DevelopmentInstanceId:
    Description: "Instance ID of the development EC2 instance for testing"
    Value: !Ref DevelopmentInstance
    Export:
      Name: !Sub "${AWS::StackName}-DevelopmentInstanceId"

  WebServerPrivateIp:
    Description: "Instance ID of the development EC2 instance for testing"
    Value: !GetAtt WebServerInstance.PrivateIp
    Export:
      Name: !Sub "${AWS::StackName}-WebServerPrivateIp"


  # MONITORING AND TROUBLESHOOTING
  CloudWatchLogGroup:
    Description: "CloudWatch log group for AgentCore runtime logs"
    Value: !Sub "/aws/bedrock-agentcore/runtimes/${AgentRuntime.AgentRuntimeId}"
    Export:
      Name: !Sub "${AWS::StackName}-LogGroup"
